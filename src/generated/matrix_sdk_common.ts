// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import * as wasmBundle from "./wasm-bindgen/index.js";
import {
  type UniffiByteArray, 
  AbstractFfiConverterByteArray, 
  FfiConverterInt32, 
  RustBuffer, 
  UniffiInternalError, 
  UniffiRustCaller, 
  uniffiCreateFfiConverterString } from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(() => new wasmBundle.RustCallStatus());

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.





const stringConverter = (() => {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return {
        stringToBytes: (s: string) => encoder.encode(s),
        bytesToString: (ab: UniffiByteArray) => decoder.decode(ab),
        stringByteLength: (s: string) => encoder.encode(s).byteLength,
    };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);


/**
 * A machine-readable representation of the authenticity for a `ShieldState`.
 */
export enum ShieldStateCode {
    /**
     * Not enough information available to check the authenticity.
     */
    AuthenticityNotGuaranteed,
    /**
     * The sending device isn't yet known by the Client.
     */
    UnknownDevice,
    /**
     * The sending device hasn't been verified by the sender.
     */
    UnsignedDevice,
    /**
     * The sender hasn't been verified by the Client's user.
     */
    UnverifiedIdentity,
    /**
     * An unencrypted event in an encrypted room.
     */
    SentInClear,
    /**
     * The sender was previously verified but changed their identity.
     */
    VerificationViolation
}

const FfiConverterTypeShieldStateCode = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = ShieldStateCode;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return ShieldStateCode.AuthenticityNotGuaranteed;
                case 2: return ShieldStateCode.UnknownDevice;
                case 3: return ShieldStateCode.UnsignedDevice;
                case 4: return ShieldStateCode.UnverifiedIdentity;
                case 5: return ShieldStateCode.SentInClear;
                case 6: return ShieldStateCode.VerificationViolation;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case ShieldStateCode.AuthenticityNotGuaranteed: return ordinalConverter.write(1, into);
                case ShieldStateCode.UnknownDevice: return ordinalConverter.write(2, into);
                case ShieldStateCode.UnsignedDevice: return ordinalConverter.write(3, into);
                case ShieldStateCode.UnverifiedIdentity: return ordinalConverter.write(4, into);
                case ShieldStateCode.SentInClear: return ordinalConverter.write(5, into);
                case ShieldStateCode.VerificationViolation: return ordinalConverter.write(6, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();




/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_matrix_sdk_common_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }

    }

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeShieldStateCode,
  }
});