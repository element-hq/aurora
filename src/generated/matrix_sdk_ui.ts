// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import * as wasmBundle from "./wasm-bindgen/index.js";
import {
  type UniffiByteArray, 
  AbstractFfiConverterByteArray, 
  FfiConverterInt32, 
  RustBuffer, 
  UniffiInternalError, 
  UniffiRustCaller, 
  uniffiCreateFfiConverterString } from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(() => new wasmBundle.RustCallStatus());

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.





const stringConverter = (() => {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return {
        stringToBytes: (s: string) => encoder.encode(s),
        bytesToString: (ab: UniffiByteArray) => decoder.decode(ab),
        stringByteLength: (s: string) => encoder.encode(s).byteLength,
    };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);


/**
 * Where this event came.
 */
export enum EventItemOrigin {
    /**
     * The event was created locally.
     */
    Local,
    /**
     * The event came from a sync response.
     */
    Sync,
    /**
     * The event came from pagination.
     */
    Pagination,
    /**
     * The event came from a cache.
     */
    Cache
}

const FfiConverterTypeEventItemOrigin = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = EventItemOrigin;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return EventItemOrigin.Local;
                case 2: return EventItemOrigin.Sync;
                case 3: return EventItemOrigin.Pagination;
                case 4: return EventItemOrigin.Cache;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case EventItemOrigin.Local: return ordinalConverter.write(1, into);
                case EventItemOrigin.Sync: return ordinalConverter.write(2, into);
                case EventItemOrigin.Pagination: return ordinalConverter.write(3, into);
                case EventItemOrigin.Cache: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





/**
 * The type of change between the previous and current pinned events.
 */
export enum RoomPinnedEventsChange {
    /**
     * Only new event ids were added.
     */
    Added,
    /**
     * Only event ids were removed.
     */
    Removed,
    /**
     * Some change other than only adding or only removing ids happened.
     */
    Changed
}

const FfiConverterTypeRoomPinnedEventsChange = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = RoomPinnedEventsChange;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomPinnedEventsChange.Added;
                case 2: return RoomPinnedEventsChange.Removed;
                case 3: return RoomPinnedEventsChange.Changed;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case RoomPinnedEventsChange.Added: return ordinalConverter.write(1, into);
                case RoomPinnedEventsChange.Removed: return ordinalConverter.write(2, into);
                case RoomPinnedEventsChange.Changed: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();




/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_matrix_sdk_ui_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }

    }

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeEventItemOrigin,
    FfiConverterTypeRoomPinnedEventsChange,
  }
});